<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Coffee Log — Map</title>

  <!-- Mapbox + PapaParse -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html,body,#map{height:100%;margin:0}
    html,body{
      font:14px/1.35 system-ui,-apple-system,"Segoe UI",Roboto,Arial,
            "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji";
      -webkit-tap-highlight-color: transparent;
    }

    :root{
      --card-bg: rgba(255,255,255,.86); --card-border: rgba(0,0,0,.06);
      --title: #0f1b10; --pill-bg: rgba(84,116,75,.12); --pill-br: rgba(84,116,75,.28);
      --glass: rgba(255,255,255,.9); --glass-br: rgba(0,0,0,.08); --text: #0f1b10;
      --muted: #5b5f5b;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    body[data-theme="dark"]{
      --card-bg: rgba(22,24,27,.85); --card-border: rgba(255,255,255,.12);
      --title: #f3f5f1; --pill-bg: rgba(160,200,160,.14); --pill-br: rgba(190,230,190,.30);
      --glass: rgba(22,24,27,.9); --glass-br: rgba(255,255,255,.12); --text: #f3f5f1;
      --muted: #c9cdc8;
    }

    /* Общие utility для безопасных зон */
    .safe-pad-top    { padding-top:    calc(8px + var(--safe-top)); }
    .safe-pad-right  { padding-right:  calc(8px + var(--safe-right)); }
    .safe-pad-bottom { padding-bottom: calc(8px + var(--safe-bottom)); }
    .safe-pad-left   { padding-left:   calc(8px + var(--safe-left)); }

    /* Левое стеклянное меню (становится компактным на мобильных) */
    .badge{
      position:absolute;top:12px;left:12px;z-index:6;
      background:var(--glass);border:1px solid var(--glass-br);color:var(--text);
      padding:8px 10px;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,.06);
      font:13px/1.2 system-ui;backdrop-filter: blur(4px);
      max-width:min(92vw,420px);
    }
    .badge .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .badge .row + .row{margin-top:6px}
    .badge label{display:inline-flex;align-items:center;gap:8px;cursor:pointer}
    .badge input[type="checkbox"]{
      width:20px;height:20px;accent-color:#567a58; /* крупнее тап-таргет */
    }
    .badge .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--glass-br)}

    /* Компактная версия панели — <details> */
    .badge details{display:none}
    .badge summary{list-style:none;cursor:pointer}
    .badge summary::-webkit-details-marker{display:none}

    .mapboxgl-popup-content{ background:transparent; padding:0; border-radius:20px; box-shadow:none }
    .mapboxgl-popup-tip{ display:none }

    .popup-card{
      position:relative; width:320px; max-width:92vw; border-radius:20px; overflow:hidden;
      background:var(--card-bg); border:1px solid var(--card-border); font:14px/1.35 system-ui
    }
    .popup-cover-box{ width:100%; height:200px; background:linear-gradient(180deg,#e7efe1,#f4f7f1) }
    .popup-cover{ width:100%; height:100%; object-fit:cover; display:block }
    .popup-body{ padding:14px }
    .popup-title{ font-weight:800; font-size:18px; margin:2px 0 6px; color:var(--title) }

    /* бейдж процесса */
    .process-badge{
      position:absolute; top:10px; right:10px; z-index:2;
      font-size:12px; padding:6px 12px; border-radius:999px;
      border:1px solid transparent; background:rgba(255,255,255,.85);
      backdrop-filter: blur(2px);
    }

    /* строки с эмодзи */
    .row{margin:2px 0; display:flex; align-items:baseline; gap:8px}
    .row-emoji{width:1.2em; text-align:center}
    .meta{margin-bottom:6px;color:var(--muted)}

    .collection-title{
      position:absolute; top:12px; left:50%; transform:translateX(-50%);
      background:var(--glass); color:var(--text); padding:8px 14px; border-radius:12px; border:1px solid var(--glass-br);
      z-index:6; max-width:80vw; overflow:hidden; text-overflow:ellipsis; font:600 16px/1.2 system-ui;
      white-space:nowrap;
    }
    a{color:#2b6cb0;text-decoration:none} a:hover{text-decoration:underline}

    /* Виджет ачивок (справа) — на мобиле делаем горизонтальный скролл */
    .achievements{
      position:absolute;top:12px;right:12px;z-index:6;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;
      max-width:46vw;
    }
    .ach-badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid var(--glass-br);font:12px/1.1 system-ui;box-shadow:0 2px 10px rgba(0,0,0,.06)}
    .ach-emoji{font-size:14px}
    .ach-title{font-weight:600}

    /* навигация по совпадающим точкам */
    .popup-nav{display:flex;align-items:center;justify-content:space-between;margin:8px 14px 14px;gap:8px}
    .popup-nav button{padding:8px 12px;border:1px solid var(--glass-br);background:var(--glass);border-radius:10px;cursor:pointer;touch-action:manipulation}
    .popup-nav .idx{font:12px/1.1 system-ui;color:var(--muted)}

    /* ====== АДАПТИВ ====== */
    /* Планшеты */
    @media (max-width: 1024px){
      .collection-title{ max-width:70vw; }
      .achievements{ max-width:50vw; }
      .popup-card{ width:360px; }
      .popup-cover-box{ height:220px; }
    }
    /* Телефоны */
    @media (max-width: 680px){
      html,body{ font-size:15px; }
      .collection-title{
        top: calc(8px + var(--safe-top));
        font-size:15px; padding:8px 12px; max-width:72vw;
      }

      /* Ачивки — в одну строку, скроллятся горизонтально */
      .achievements{
        top: auto; bottom: calc(12px + var(--safe-bottom));
        right: calc(12px + var(--safe-right));
        left: calc(12px + var(--safe-left));
        gap:10px; flex-wrap:nowrap; overflow-x:auto; scrollbar-width:none;
        -ms-overflow-style:none;
      }
      .achievements::-webkit-scrollbar{ display:none; }
      .ach-badge{ padding:8px 10px; }

      /* Панель фильтров уезжает вниз-слева и сворачивается */
      .badge{
        top: auto; bottom: calc(12px + var(--safe-bottom));
        left: calc(12px + var(--safe-left));
        right: auto; padding:0; border-radius:14px; max-width: min(86vw, 420px);
      }
      .badge .row{ display:none } /* скрываем обычную раскладку */
      .badge details{ display:block; }
      .badge details[open] .panel{ display:block; }
      .badge summary{
        padding:10px 12px; background:var(--glass);
        border-radius:14px; border:1px solid var(--glass-br);
        display:flex; align-items:center; gap:8px;
      }
      .badge .panel{
        padding:10px 12px; border-top:1px solid var(--glass-br);
        display:none;
      }
      .badge .chip{ padding:6px 10px; }

      /* Попап — почти на весь экран по ширине, картинка ниже */
      .mapboxgl-popup{
        max-width: 96vw !important;
      }
      .popup-card{ width: min(96vw, 520px); }
      .popup-cover-box{ height: 34vh; min-height: 160px; }
      .popup-title{ font-size:17px; }
      .process-badge{ font-size:12px; padding:6px 10px; }

      /* Чтобы контролы Mapbox не налезали на панель */
      .mapboxgl-ctrl-bottom-right{
        bottom: calc(56px + var(--safe-bottom)) !important;
        right: calc(8px + var(--safe-right)) !important;
      }
    }

    /* Очень узкие телефоны */
    @media (max-width: 380px){
      .popup-cover-box{ height:30vh; }
      .ach-badge{ font-size:11px; }
      .collection-title{ font-size:14px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="badge safe-pad-left safe-pad-bottom" id="badge">
    <!-- Мобильная сворачиваемая версия заполняется ниже в JS тем же контентом -->
    <details>
      <summary>☕ Панель</summary>
      <div class="panel"></div>
    </details>
  </div>
  <div class="achievements safe-pad-right safe-pad-bottom" id="achievements"></div>
  <div class="collection-title safe-pad-top" id="collectionTitle">My coffee experience</div>

<script>
  /* ==== настройки ==== */
  const MAPBOX_TOKEN = 'pk.eyJ1IjoibWF4MTQwNTE5OTMtY29mZmVlIiwiYSI6ImNtZTVic3c3dTBxZDMya3F6MzV0ejY1YjcifQ._YoZjruPVrVHtusEf8OkZw';
  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSbms6-9Pie6VdyXzbjiMwWeIF-mxMvMiyFHaRI1DJE0nPNkSG99lewaeeU8YIuj7Y8vxzJGOD2md1v/pub?gid=1055803810&single=true&output=csv';

  const theme = (new URLSearchParams(location.search).get('style') || 'light').toLowerCase();
  document.body.dataset.theme = theme;
  const FLAG_MODE = (new URLSearchParams(location.search).get('flag') || 'img').toLowerCase(); // 'img' | 'emoji'

  /* ==== карта ==== */
  mapboxgl.accessToken = MAPBOX_TOKEN;
  const map = new mapboxgl.Map({
    container: 'map',
    style: theme === 'dark' ? 'mapbox://styles/mapbox/dark-v11' : 'mapbox://styles/mapbox/light-v11',
    center: [12, 20],
    zoom: 2.2,
    attributionControl: true,
    renderWorldCopies: false
  });
  map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');

  // Убираем зум по двойному тапу внутри попапов (чтобы листать контент)
  map.scrollZoom.enable();
  map.doubleClickZoom.disable();

  map.on('load', () => {
    if (!map.getSource('terrain-dem')) {
      map.addSource('terrain-dem', { type: 'raster-dem', url: 'mapbox://mapbox.terrain-rgb', tileSize: 512 });
    }
    map.setTerrain({ source: 'terrain-dem', exaggeration: 1.6 });
    if (!map.getLayer('sky')) {
      map.addLayer({ id: 'sky', type: 'sky', paint: { 'sky-type':'atmosphere', 'sky-atmosphere-sun':[10,25], 'sky-atmosphere-sun-intensity': 10 } });
    }
    map.setFog({ range:[0.6, 12], color:'#f6efe7', 'high-color':'#d4c7b8', 'horizon-blend':0.2, 'star-intensity':0 });
  });

  /* ==== утилиты ==== */
  const normKey = (k) => String(k||'').toLowerCase().replace(/\s+/g,' ').trim();

  function pickSmart(row, candidates){
    for (const k of candidates) if (row[k] !== undefined && row[k] !== '') return row[k];
    const nRow = {}; for (const key in row) nRow[normKey(key)] = row[key];
    for (const cand of candidates){ const nCand = normKey(cand); if (nRow[nCand] !== undefined && nRow[nCand] !== '') return nRow[nCand]; }
    const allKeys = Object.keys(row);
    for (const cand of candidates){
      const nCand = normKey(cand);
      for (const key of allKeys){
        if (normKey(key).startsWith(nCand) && row[key] !== '') return row[key];
      }
    }
    return '';
  }

  const toNumber = (v) => (typeof v==='number') ? v : (typeof v==='string' ? parseFloat(v.replace(',', '.')) : NaN);
  const escapeHtml = (s) => String(s||'').replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  const escapeAttr = (s) => String(s||'').replace(/"/g,'&quot;');

  // === нормализация процесса + цвета ===
  function normalizeProcessName(raw){
    const s = String(raw||'').toLowerCase();
    if (!s) return 'other';
    if (/(honey|red honey|yellow honey|white honey|black honey)/.test(s)) return 'honey';
    if (/(anaer|carbonic|cm|термо|thermal|macerat|carbonique)/.test(s)) return 'anaerobic';
    if (/(wash|fully washed|wet|мыта|мытый|вымыт)/.test(s)) return 'washed';
    if (/(natur|dry|сух)/.test(s)) return 'natural';
    if (/(yeast|који|koji|enzym|фермент|co-?ferment|double|triple|wine)/.test(s)) return 'experimental';
    return 'other';
  }
  function processColors(pType){
    switch(pType){
      case 'washed':      return { point:'#2e7d32', bg:'#d7f0df', br:'#82b998', txt:'#205b3a' };
      case 'natural':     return { point:'#c0392b', bg:'#ffd9d2', br:'#e59883', txt:'#7a1d12' };
      case 'honey':       return { point:'#c77f0a', bg:'#ffe9c6', br:'#e9b86a', txt:'#6b4800' };
      case 'anaerobic':   return { point:'#6a3cbc', bg:'#e6d7ff', br:'#b79de5', txt:'#3b2b6f' };
      case 'experimental':return { point:'#2c5aa0', bg:'#dde9f7', br:'#9bb9e6', txt:'#1f3a63' };
      default:            return { point:'#777777', bg:'#eeeeee', br:'#cccccc', txt:'#333333' };
    }
  }

  // Drive helpers
  function extractDriveId(url){
    const m = String(url||'').match(/(?:\/d\/|id=)([-\w]{25,})/);
    return m ? m[1] : null;
  }
  function driveImgHtml(url){
    if (!url) return '';
    if (/thumbnail\?id=/.test(url)) return `<img class="popup-cover" loading="lazy" src="${escapeAttr(url)}" alt="photo">`;
    const id = extractDriveId(url);
    const chain = id ? [
      `https://drive.google.com/thumbnail?id=${id}&sz=w1600`,
      `https://lh3.googleusercontent.com/d/${id}=w1600`,
      `https://drive.google.com/uc?export=view&id=${id}`,
      `https://drive.google.com/uc?export=download&id=${id}`
    ] : [url];
    const first = chain.shift();
    return `<img class="popup-cover" loading="lazy" src="${escapeAttr(first)}"
             alt="photo" onerror="driveImgFallback(this, ${JSON.stringify(chain)})">`;
  }
  function driveImgFallback(img, list){ if (!list || !list.length) { img.remove(); return; } img.src = list.shift(); }
  window.driveImgFallback = driveImgFallback;

  // флаг: emoji → ISO2 PNG при необходимости
  function flagFromRow(flagEmojiCell, iso2Cell){
    const emoji = String(flagEmojiCell||'').trim();
    if (FLAG_MODE==='emoji' && emoji) return emoji;
    const code = String(iso2Cell||'').trim().toLowerCase();
    return (code.length===2)
      ? `<img src="https://flagcdn.com/24x18/${code}.png" alt="${code.toUpperCase()}" width="24" height="18" style="vertical-align:-2px;border-radius:2px">`
      : (FLAG_MODE==='emoji' ? emoji : '');
  }

  /* ==== заголовки CSV ==== */
  const HEADERS = {
    timestamp:       ['Timestamp'],
    email:           ['Email Address'],
    uploader:        ['Uploader'],
    originCountry:   ['Origin country'],
    originRegion:    ['Origin region'],
    farmName:        ['Farm name'],
    process:         ['Process'],
    brewMethod:      ['Brew method'],
    whereConsumed:   ['Where consumed'],
    cafeName:        ['Cafe name'],
    cafeUrl:         ['Cafe URL'],
    consumedCity:    ['Consumed city','Consumed city '],
    consumedAddr:    ['Consumed address'],
    recipe:          ['Recipe'],
    roasterName:     ['Roaster name'],
    roasterCity:     ['Roaster city'],
    fileUpload:      ['File upload','File upload '],
    lat:             ['Latitude (lat)','Latitude'],
    lng:             ['Longitude (lng)','Longitude'],
    photoUrl:        ['Photo (URL)'],
    geocodeSource:   ['Geocode source'],
    geocodeAccuracy: ['Geocode accuracy'],
    matchedName:     ['Matched name'],
    countryIso2:     ['Country ISO2'],
    flagEmoji:       ['Flag emoji']
  };

  function rowsToGeoJSON(rows) {
    const features = [];
    for (const row of rows) {
      const lat = toNumber(pickSmart(row, HEADERS.lat));
      const lng = toNumber(pickSmart(row, HEADERS.lng));
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

      let photo = pickSmart(row, HEADERS.photoUrl);
      if (!photo) photo = pickSmart(row, HEADERS.fileUpload);

      const processRaw  = pickSmart(row, HEADERS.process);
      const processNorm = normalizeProcessName(processRaw);

      const p = {
        timestamp:       pickSmart(row, HEADERS.timestamp),
        email:           pickSmart(row, HEADERS.email),
        uploader:        pickSmart(row, HEADERS.uploader),
        originCountry:   pickSmart(row, HEADERS.originCountry),
        originRegion:    pickSmart(row, HEADERS.originRegion),
        farmName:        pickSmart(row, HEADERS.farmName),
        process:         processRaw,
        process_norm:    processNorm,
        brewMethod:      pickSmart(row, HEADERS.brewMethod),
        whereConsumed:   pickSmart(row, HEADERS.whereConsumed),
        cafeName:        pickSmart(row, HEADERS.cafeName),
        cafeUrl:         pickSmart(row, HEADERS.cafeUrl),
        consumedCity:    pickSmart(row, HEADERS.consumedCity),
        consumedAddr:    pickSmart(row, HEADERS.consumedAddr),
        recipe:          pickSmart(row, HEADERS.recipe),
        roasterName:     pickSmart(row, HEADERS.roasterName),
        roasterCity:     pickSmart(row, HEADERS.roasterCity),
        photoUrl:        photo,
        matchedName:     pickSmart(row, HEADERS.matchedName),
        countryIso2:     pickSmart(row, HEADERS.countryIso2),
        flagEmoji:       pickSmart(row, HEADERS.flagEmoji)
      };

      features.push({ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:p });
    }
    return { type:'FeatureCollection', features };
  }

  function fitToData(geojson){
    if (!geojson.features.length) return;
    const b = new mapboxgl.LngLatBounds();
    geojson.features.forEach(f => b.extend(f.geometry.coordinates));
    map.fitBounds(b, { padding: 40, duration: 700, maxZoom: 10 });
  }

  /* ==== карточка ==== */
  function popupHTML(p) {
    const flag = flagFromRow(p.flagEmoji, p.countryIso2);
    const country = p.originCountry ? ((flag ? flag + ' ' : '') + escapeHtml(p.originCountry)) : '';
    const region  = escapeHtml(p.originRegion || '');
    const place   = [country, region].filter(Boolean).join(', ');
    const roaster = (p.roasterName ? escapeHtml(p.roasterName) : '') +
                    (p.roasterCity ? ' (' + escapeHtml(p.roasterCity) + ')' : '');
    const photo = `<div class="popup-cover-box">${ p.photoUrl ? driveImgHtml(p.photoUrl) : '' }</div>`;

    const rows = [];
    if (p.brewMethod) rows.push(emojiRow('🧉','Method', escapeHtml(p.brewMethod)));

    if (p.whereConsumed || p.consumedCity || p.consumedAddr || p.cafeUrl) {
      const bits = [];
      if (p.whereConsumed) bits.push(escapeHtml(p.whereConsumed));
      if (p.consumedCity)  bits.push(escapeHtml(p.consumedCity));
      let whereHtml = bits.join(' — ');
      if (p.cafeUrl) whereHtml += ` <a href="${escapeAttr(p.cafeUrl)}" target="_blank" rel="noopener" title="Ссылка на заведение">🔗</a>`;
      rows.push(emojiRow('📍','Where', whereHtml));
      if (p.consumedAddr) rows.push(`<div class="row" style="margin-left:1.6em;color:#666">${escapeHtml(p.consumedAddr)}</div>`);
    }

    if (p.recipe)   rows.push(emojiRow('📋','Recipe', escapeHtml(p.recipe)));
    if (roaster)    rows.push(emojiRow('🏭','Roaster', roaster));
    if (p.uploader) rows.push(emojiRow('👤','By', escapeHtml(p.uploader)));

    const pType = p.process_norm || 'other';
    const col = processColors(pType);
    const badge = p.process
      ? `<div class="process-badge" style="background:${col.bg};border-color:${col.br};color:${col.txt}">${escapeHtml(p.process)}</div>`
      : '';

    return `
      <div class="popup-card">
        ${badge}
        ${photo}
        <div class="popup-body">
          <div class="popup-title">${escapeHtml(p.farmName || 'Без названия')}</div>
          <div class="meta">${place || '—'}</div>
          ${rows.join('')}
        </div>
      </div>
    `;

    function emojiRow(emoji, title, val){
      return `<div class="row"><span class="row-emoji" title="${escapeAttr(title)}">${emoji}</span><span>${val||''}</span></div>`;
    }
  }

  /* ==== линии/города/страны и пр. (без изменений в логике) ==== */
  const CITY_CACHE_NS = 'coffee_city_cache_v1';
  const cityCache = JSON.parse(localStorage.getItem(CITY_CACHE_NS) || '{}');
  const cacheSave = () => localStorage.setItem(CITY_CACHE_NS, JSON.stringify(cityCache));

  async function geocodeCityName(name){
    const key = String(name||'').trim().toLowerCase();
    if (!key) return null;
    if (cityCache[key]) return cityCache[key];
    const url = 'https://api.mapbox.com/geocoding/v5/mapbox.places/' +
      encodeURIComponent(name) + '.json?' + new URLSearchParams({
        access_token: MAPBOX_TOKEN, types: 'place,locality', language: 'ru,en', limit: '1'
      });
    const res = await fetch(url);
    if (!res.ok) return null;
    const json = await res.json();
    const f = (json.features||[])[0];
    if (!f || !Array.isArray(f.center)) return null;
    const [lng, lat] = f.center;
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
    const pt = {lng, lat};
    cityCache[key] = pt; cacheSave();
    return pt;
  }

  async function geocodeCities(names){
    const out = {};
    for (const name of names){ out[name] = await geocodeCityName(name); }
    return out;
  }

  function buildRouteFeatures(pointFeatures, cityMap){
    const lines = [];
    for (const f of pointFeatures){
      const p = f.properties;
      const [farmLng, farmLat] = f.geometry.coordinates;

      if (p.roasterCity){
        const rc = cityMap[p.roasterCity];
        if (rc){
          lines.push({
            type:'Feature',
            geometry:{ type:'LineString', coordinates:[[farmLng,farmLat],[rc.lng,rc.lat]] },
            properties:{ kind:'farm_to_roaster', farm:p.farmName||'', roasterCity:p.roasterCity||'' }
          });
        }
      }
      if (p.roasterCity && p.consumedCity){
        const rc = cityMap[p.roasterCity];
        const uc = cityMap[p.consumedCity];
        if (rc && uc){
          lines.push({
            type:'Feature',
            geometry:{ type:'LineString', coordinates:[[rc.lng,rc.lat],[uc.lng,uc.lat]] },
            properties:{ kind:'roaster_to_consumed', roasterCity:p.roasterCity||'', consumedCity:p.consumedCity||'' }
          });
        }
      }
    }
    return lines;
  }

  function highlightRouteFor(p){
    if (!map.getLayer('route-highlight')) return;
    const filt = ['any'];
    if (p.roasterCity){
      filt.push(['all',
        ['==',['get','kind'],'farm_to_roaster'],
        ['==',['get','roasterCity'], String(p.roasterCity)]
      ]);
      if (p.consumedCity){
        filt.push(['all',
          ['==',['get','kind'],'roaster_to_consumed'],
          ['==',['get','roasterCity'], String(p.roasterCity)],
          ['==',['get','consumedCity'], String(p.consumedCity)]
        ]);
      }
    }
    map.setFilter('route-highlight', filt.length>1 ? filt : ['==', ['get','kind'], '___nope___']);
  }
  function clearRouteHighlight(){
    if (map.getLayer('route-highlight')){
      map.setFilter('route-highlight', ['==', ['get','kind'], '___nope___']);
    }
  }

  const EPS = 1e-6;
  const sameCoord = (a,b) => Math.abs(a[0]-b[0])<EPS && Math.abs(a[1]-b[1])<EPS;

  function dedupeFeatures(arr){
    const seen = new Set();
    const out = [];
    for (const f of arr){
      const c = f.geometry.coordinates;
      const key = JSON.stringify([
        +c[0].toFixed(7), +c[1].toFixed(7),
        f.properties?.timestamp || '',
        f.properties?.farmName || '',
        f.properties?.roasterName || '',
        f.properties?.uploader || '',
        f.properties?.process || '',
        f.properties?.recipe || '',
        f.properties?.photoUrl || ''
      ]);
      if (!seen.has(key)){ seen.add(key); out.push(f); }
    }
    return out;
  }

  function showMultiPopup(features, coord){
    let i = 0;
    const popup = new mapboxgl.Popup({ offset:12, maxWidth:'360px' }).setLngLat(coord);

    const render = () => {
      const p = features[i].properties;
      const nav = (features.length>1)
        ? `<div class="popup-nav">
             <button type="button" data-prev>◀</button>
             <div class="idx">${i+1} из ${features.length}</div>
             <button type="button" data-next>▶</button>
           </div>` : '';
      popup.setHTML(popupHTML(p) + nav);

      setTimeout(()=> {
        const el = popup.getElement();
        el?.querySelector('[data-prev]')?.addEventListener('click', ()=>{ i=(i-1+features.length)%features.length; render(); highlightRouteFor(features[i].properties); }, {passive:true});
        el?.querySelector('[data-next]')?.addEventListener('click', ()=>{ i=(i+1)%features.length; render(); highlightRouteFor(features[i].properties); }, {passive:true});
      }, 0);

      highlightRouteFor(p);
    };

    popup.on('close', clearRouteHighlight);
    popup.addTo(map);
    render();
  }

  const WORLDVIEW = 'US';
  function getVisitedCountriesIso2(pointFeatures){
    const set = new Set();
    for (const f of pointFeatures){
      const c = String(f.properties?.countryIso2 || '').trim().toUpperCase();
      if (/^[A-Z]{2}$/.test(c)) set.add(c);
    }
    return set;
  }
  function buildVisitedFilter(iso2List){
    return [
      'all',
      ['==', ['get','disputed'], 'false'],
      ['any', ['==','all',['get','worldview']], ['in', WORLDVIEW, ['get','worldview']]],
      ['in', ['get','iso_3166_1'], ['literal', iso2List]]
    ];
  }
  function ensureCountriesLayers(){
    if (!map.getSource('countries')){
      map.addSource('countries', { type:'vector', url:'mapbox://mapbox.country-boundaries-v1' });
    }
    const beforeId = 'admin-1-boundary-bg';
    if (!map.getLayer('countries-visited-fill')){
      map.addLayer({
        id:'countries-visited-fill',
        type:'fill',
        source:'countries',
        'source-layer':'country_boundaries',
        paint:{ 'fill-color':'#76a96b', 'fill-opacity':0.35 }
      }, beforeId);
      map.setLayoutProperty('countries-visited-fill','visibility','none');
    }
    if (!map.getLayer('countries-visited-outline')){
      map.addLayer({
        id:'countries-visited-outline',
        type:'line',
        source:'countries',
        'source-layer':'country_boundaries',
        paint:{ 'line-color':'#567a58', 'line-width':0.8, 'line-opacity':0.85 }
      }, beforeId);
      map.setLayoutProperty('countries-visited-outline','visibility','none');
    }
  }
  function setCountriesVisibility(state){
    const vis = state ? 'visible' : 'none';
    if (map.getLayer('countries-visited-fill'))   map.setLayoutProperty('countries-visited-fill',   'visibility', vis);
    if (map.getLayer('countries-visited-outline'))map.setLayoutProperty('countries-visited-outline','visibility', vis);
  }

  const HOME_RE = /(home|дом|house|дома)/i;
  const normalizeName = s => String(s||'').replace(/\s+/g,' ').trim();

  function buildCityPoints(pointFeatures, cityMap){
    const agg = new Map();
    for (const f of pointFeatures){
      const p = f.properties;

      if (p.roasterCity){
        const city = normalizeName(p.roasterCity);
        const pt = cityMap[city];
        if (pt){
          const key = city.toLowerCase();
          const o = agg.get(key) || { city, lng:pt.lng, lat:pt.lat, roasters:new Set(), places:new Set(), home:false };
          const rn = normalizeName(p.roasterName);
          if (rn) o.roasters.add(rn.toLowerCase());
          agg.set(key, o);
        }
      }
      if (p.consumedCity){
        const city = normalizeName(p.consumedCity);
        const pt = cityMap[city];
        if (pt){
          const key = city.toLowerCase();
          const o = agg.get(key) || { city, lng:pt.lng, lat:pt.lat, roasters:new Set(), places:new Set(), home:false };
          const cafe = normalizeName(p.cafeName);
          if (cafe) o.places.add(cafe.toLowerCase());
          if (p.whereConsumed && HOME_RE.test(p.whereConsumed)) o.home = true;
          agg.set(key, o);
        }
      }
    }

    const features = [];
    for (const o of agg.values()){
      const roasters = [...o.roasters].map(s => s.replace(/\b\w/g, c=>c.toUpperCase()));
      const places   = [...o.places].map(s => s.replace(/\b\w/g, c=>c.toUpperCase()));
      const kind = roasters.length && (places.length || o.home) ? 'both' : (roasters.length ? 'roaster' : 'consumed');
      const size = Math.max(roasters.length + places.length + (o.home?1:0), 1);
      features.push({
        type:'Feature',
        geometry:{ type:'Point', coordinates:[o.lng,o.lat] },
        properties:{ city:o.city, roasters, places, home:o.home, kind, size }
      });
    }
    return { type:'FeatureCollection', features };
  }

  function cityPopupHTML(props){
    const rows = [];
    if (props.roasters && props.roasters.length){
      rows.push(row('🏭', props.roasters.join(', ')));
    }
    const placeBits = [];
    if (props.places && props.places.length) placeBits.push(...props.places);
    if (props.home) placeBits.push('дом');
    if (placeBits.length){
      rows.push(row('🔻', placeBits.join(', ')));
    }
    return `
      <div class="popup-card">
        <div class="popup-body">
          <div class="popup-title">${escapeHtml(props.city)}</div>
          ${rows.join('')}
        </div>
      </div>
    `;
    function row(emoji, text){
      return `<div class="row"><span class="row-emoji">${emoji}</span><span>${escapeHtml(text)}</span></div>`;
    }
  }

  function setRoutesVisibility(state){
    const vis = state ? 'visible' : 'none';
    ['route-farm-roaster','route-roaster-consumed','route-highlight'].forEach(id=>{
      if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
    });
    if (!state) clearRouteHighlight();
  }

  const ACHIEVEMENTS = [
    { id:'first_sip',   emoji:'☕️', title:'Первый глоток', color:{ bg:'#d1fae5', br:'#99f6e4', txt:'#065f46' }, earned:(m)=> m.total>=1 },
    { id:'countries_3', emoji:'🌍', title:'Страны ×3',     color:{ bg:'#fef3c7', br:'#fde68a', txt:'#92400e' }, earned:(m)=> m.countries>=3 },
    { id:'processes_3', emoji:'🧪', title:'Процессы ×3',   color:{ bg:'#ede9fe', br:'#ddd6fe', txt:'#4c1d95' }, earned:(m)=> m.processTypes>=3 }
  ];
  function computeMetrics(pointFeatures){
    const countriesSet = getVisitedCountriesIso2(pointFeatures);
    const proc = new Set();
    for (const f of pointFeatures){
      const t = (f.properties?.process_norm)||'';
      if (t && t !== 'other') proc.add(t);
    }
    return { total: pointFeatures.length, countries: countriesSet.size, processTypes: proc.size };
  }
  function renderAchievements(metrics){
    const earned = ACHIEVEMENTS.filter(a => a.earned(metrics));
    const el = document.getElementById('achievements');
    el.innerHTML = earned.map(a =>
      `<div class="ach-badge" style="background:${a.color.bg};border-color:${a.color.br};color:${a.color.txt}" title="${escapeAttr(a.title)}">
         <span class="ach-emoji">${a.emoji}</span><span class="ach-title">${escapeHtml(a.title)}</span>
       </div>`
    ).join('');
  }

  /* ==== загрузка CSV → точки + линии + страны + ачивки ==== */
  Papa.parse(CSV_URL, {
    download: true, header: true, dynamicTyping: false,
    complete: async (results) => {
      const geojsonPoints = rowsToGeoJSON(results.data || []);
      const pointFeatures = geojsonPoints.features;

      // Имя(ена) загрузчика(ов) в шапку
      const uploaders = [...new Set(pointFeatures.map(f => (f.properties?.uploader||'').trim()).filter(Boolean))];
      const owner = uploaders[0] ? (uploaders.length>1 ? `${uploaders[0]} +${uploaders.length-1}` : uploaders[0]) : '';
      document.getElementById('collectionTitle').textContent = owner ? `My coffee experience — ${owner}` : 'My coffee experience';

      // Города для линий/точек
      const want = new Set();
      for (const f of pointFeatures){
        const p = f.properties;
        if (p.roasterCity)  want.add(String(p.roasterCity).trim());
        if (p.consumedCity) want.add(String(p.consumedCity).trim());
      }
      const uniqueCities = [...want].filter(Boolean);
      const cityCoordsMap = await geocodeCities(uniqueCities);
      const lineFeatures = buildRouteFeatures(pointFeatures, cityCoordsMap);
      const cityPoints = buildCityPoints(pointFeatures, cityCoordsMap);

      // Страны
      const visitedList = [...getVisitedCountriesIso2(pointFeatures)];

      // Меню слева (без счётчика линий)
      const badgeEl = document.getElementById('badge');
      const panelHTML = `
        <div class="row">
          <span class="chip" title="Точек">☕ ${pointFeatures.length}</span>
          <span class="chip" title="Стран">🌍 ${visitedList.length}</span>
        </div>
        <div class="row" style="margin-top:8px">
          <label title="Показывать маршруты"><input type="checkbox" id="toggleRoutes"> 🧵 Маршруты</label>
          <label title="Закрашивать страны"><input type="checkbox" id="toggleVisited"> 🎨🌍 Страны</label>
        </div>
      `;
      // desktop/tablet раскладка
      badgeEl.insertAdjacentHTML('beforeend', panelHTML);
      // мобильная панель внутрь <details>
      const detailsPanel = badgeEl.querySelector('.panel');
      if (detailsPanel) detailsPanel.innerHTML = panelHTML;

      // Ачивки (справа)
      renderAchievements(computeMetrics(pointFeatures));

      function addLayers(){
        // источники
        if (!map.getSource('brews')) {
          map.addSource('brews', { type:'geojson', data:geojsonPoints, cluster:true, clusterMaxZoom:14, clusterRadius:50 });
        } else {
          map.getSource('brews').setData(geojsonPoints);
        }
        if (!map.getSource('routes')) {
          map.addSource('routes', { type:'geojson', data:{ type:'FeatureCollection', features: lineFeatures } });
        } else {
          map.getSource('routes').setData({ type:'FeatureCollection', features: lineFeatures });
        }
        if (!map.getSource('city-points')) {
          map.addSource('city-points', { type:'geojson', data: cityPoints });
        } else {
          map.getSource('city-points').setData(cityPoints);
        }

        // страны
        ensureCountriesLayers();
        const filt = buildVisitedFilter(visitedList);
        map.setFilter('countries-visited-fill', filt);
        map.setFilter('countries-visited-outline', filt);
        setCountriesVisibility(false);

        // линии (по умолчанию скрыты — включаются чекбоксом)
        if (!map.getLayer('route-farm-roaster')){
          map.addLayer({ id:'route-farm-roaster', type:'line', source:'routes',
            filter:['==',['get','kind'],'farm_to_roaster'],
            paint:{ 'line-color':'#006d2c', 'line-width':2, 'line-opacity':0.6 } });
        }
        if (!map.getLayer('route-roaster-consumed')){
          map.addLayer({ id:'route-roaster-consumed', type:'line', source:'routes',
            filter:['==',['get','kind'],'roaster_to_consumed'],
            paint:{ 'line-color':'#08519c', 'line-width':2, 'line-opacity':0.6, 'line-dasharray':[2,2] } });
        }
        if (!map.getLayer('route-highlight')){
          map.addLayer({ id:'route-highlight', type:'line', source:'routes',
            filter:['==', ['get','kind'], '___nope___'],
            paint:{ 'line-color':'#ff7f00', 'line-width':5, 'line-opacity':0.9 } });
        }
        setRoutesVisibility(false);

        // кластеры и точки
        if (!map.getLayer('clusters')){
          map.addLayer({
            id:'clusters', type:'circle', source:'brews', filter:['has','point_count'],
            paint:{
              'circle-color': ['step',['get','point_count'],'#9ecae1',10,'#6baed6',30,'#3182bd'],
              'circle-radius': ['step',['get','point_count'],16,10,20,30,26]
            }
          });
          map.addLayer({
            id:'cluster-count', type:'symbol', source:'brews', filter:['has','point_count'],
            layout:{ 'text-field': ['get','point_count_abbreviated'], 'text-size':12 },
            paint:{ 'text-color':'#08306b' }
          });
          map.addLayer({
            id:'unclustered', type:'circle', source:'brews', filter:['!', ['has','point_count']],
            paint:{
              'circle-color': [
                'match', ['get','process_norm'],
                'washed',      '#2e7d32',
                'natural',     '#c0392b',
                'honey',       '#c77f0a',
                'anaerobic',   '#6a3cbc',
                'experimental','#2c5aa0',
                /* other */    '#777777'
              ],
              'circle-radius':6,
              'circle-stroke-width':1,
              'circle-stroke-color':'#fff'
            }
          });

          map.on('click','clusters',(e)=>{
            const f = map.queryRenderedFeatures(e.point,{layers:['clusters']})[0];
            map.getSource('brews').getClusterExpansionZoom(f.properties.cluster_id,(err,zoom)=>{
              if (!err) map.easeTo({center:f.geometry.coordinates, zoom});
            });
          });

          // Клик по обычной точке — мульти-попап
          map.on('click','unclustered',(e)=>{
            const clicked = e.features[0];
            const coord = clicked.geometry.coordinates;
            const buf = 6; // px
            const box = [[e.point.x-buf, e.point.y-buf],[e.point.x+buf, e.point.y+buf]];
            const inBox = map.queryRenderedFeatures(box, { layers:['unclustered'] });
            const nearSame = inBox.filter(f => sameCoord(f.geometry.coordinates, coord));
            const features = dedupeFeatures(nearSame.length ? nearSame : [clicked]);
            showMultiPopup(features, coord);
          });

          map.on('click', (e) => {
            const feats = map.queryRenderedFeatures(e.point, {layers:['unclustered','clusters']});
            if (!feats.length) clearRouteHighlight();
          });

          map.on('mouseenter','clusters',()=>map.getCanvas().style.cursor='pointer');
          map.on('mouseleave','clusters',()=>map.getCanvas().style.cursor='');
          map.on('mouseenter','unclustered',()=>map.getCanvas().style.cursor='pointer');
          map.on('mouseleave','unclustered',()=>map.getCanvas().style.cursor='');
        }

        /* ==== Слой единых городских точек ==== */
        if (!map.getLayer('city-points')){
          map.addLayer({
            id:'city-points',
            type:'circle',
            source:'city-points',
            paint:{
              'circle-color': [
                'match', ['get','kind'],
                'both',     '#8e44ad',
                'roaster',  '#006d2c',
                'consumed', '#08519c',
                /* default */ '#666666'
              ],
              'circle-opacity':0.75,
              'circle-stroke-color':'#ffffff',
              'circle-stroke-width':1.2,
              'circle-radius':['interpolate',['linear'],['get','size'],1,6,3,8,6,11,10,14]
            }
          });
          map.on('click','city-points',(e)=>{
            const f = e.features[0];
            new mapboxgl.Popup({offset:10})
              .setLngLat(f.geometry.coordinates)
              .setHTML(cityPopupHTML(f.properties))
              .addTo(map);
          });
          map.on('mouseenter','city-points',()=>map.getCanvas().style.cursor='pointer');
          map.on('mouseleave','city-points',()=>map.getCanvas().style.cursor='');
        }

        fitToData(geojsonPoints);
      }

      if (map.isStyleLoaded && map.isStyleLoaded()) addLayers();
      else map.on('load', addLayers);

      // чекбоксы — и на десктопной панели, и внутри мобильного <details>
      function bindToggles(root=document){
        root.getElementById('toggleVisited')?.addEventListener('change', (e)=> setCountriesVisibility(e.target.checked), {passive:true});
        root.getElementById('toggleRoutes')?.addEventListener('change', (e)=> setRoutesVisibility(e.target.checked), {passive:true});
      }
      bindToggles(document);
      if (detailsPanel) bindToggles(detailsPanel.ownerDocument || document);
    },
    error: (err) => {
      document.getElementById('badge').textContent = 'Ошибка загрузки CSV';
      console.error('CSV error:', err);
    }
  });
</script>
</body>
</html>
