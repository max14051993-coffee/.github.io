import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { rowsToGeoJSON, buildRouteFeatures, buildCityPoints, computeMetrics } from '../js/data-loader.js';
import { CITY_COORD_FALLBACKS } from '../js/city-fallbacks.js';
import { normalizeName } from '../js/utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function parseCsv(text) {
  const lines = text.split(/\r?\n/);
  const headerIndex = lines.findIndex((line) => line.startsWith('Timestamp,'));
  if (headerIndex === -1) throw new Error('Could not locate header row');
  const headers = splitCsvLine(lines[headerIndex]);
  const records = [];
  for (let i = headerIndex + 1; i < lines.length; i += 1) {
    const line = lines[i];
    if (!line || !line.trim()) continue;
    const cells = splitCsvLine(line);
    const record = {};
    headers.forEach((header, idx) => {
      if (!header) return;
      record[header] = cells[idx] ?? '';
    });
    records.push(record);
  }
  return records;
}

function splitCsvLine(line) {
  const cells = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];
    if (inQuotes) {
      if (char === '"') {
        if (line[i + 1] === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else if (char === '"') {
      inQuotes = true;
    } else if (char === ',') {
      cells.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  cells.push(current);
  return cells;
}

function buildCityCoordsMap(records) {
  const map = {};
  const missing = new Set();
  const consider = ['Roaster city', 'Consumed city'];
  for (const record of records) {
    for (const field of consider) {
      const raw = record[field];
      if (!raw) continue;
      const trimmed = normalizeName(raw);
      const normalized = trimmed.toLowerCase();
      if (!normalized) continue;
      if (!map[normalized]) {
        const fallback = CITY_COORD_FALLBACKS[normalized];
        if (fallback) {
          map[normalized] = fallback;
        } else {
          missing.add(trimmed);
        }
      }
      if (!map[trimmed]) {
        const fallback = CITY_COORD_FALLBACKS[normalized];
        if (fallback) {
          map[trimmed] = fallback;
        }
      }
      if (!CITY_COORD_FALLBACKS[normalized]) {
        missing.add(raw);
      }
    }
  }
  if (missing.size) {
    console.warn('Missing fallback coordinates for cities:', [...missing]);
  }
  return map;
}

async function main() {
  const csvPath = path.resolve(__dirname, '../data/coffee-log.csv');
  const outPath = path.resolve(__dirname, '../js/static-dataset.js');
  const csvText = await fs.readFile(csvPath, 'utf8');
  const records = parseCsv(csvText);
  const geojsonPoints = rowsToGeoJSON(records);
  const pointFeatures = geojsonPoints.features;
  const cityCoordsMap = buildCityCoordsMap(records);
  const lineFeatures = buildRouteFeatures(pointFeatures, cityCoordsMap);
  const cityPoints = buildCityPoints(pointFeatures, cityCoordsMap);
  const metrics = computeMetrics(pointFeatures, cityCoordsMap);

  const data = {
    geojsonPoints,
    pointFeatures,
    cityCoordsMap,
    lineFeatures,
    cityPoints,
    metrics,
  };

  const header = '// This file is auto-generated by scripts/build-static-data.mjs\n';
  const content = `${header}export const STATIC_DATA = ${JSON.stringify(data, null, 2)};\n`;
  await fs.writeFile(outPath, content, 'utf8');
  console.log(`Wrote ${outPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
